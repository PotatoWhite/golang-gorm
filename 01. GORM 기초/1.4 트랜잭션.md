## 1.4 Transaction

트랜잭션은 여러 CRUD 연산을 하나의 논리적 단위로 묶어 **모두 성공하면 커밋(Commit)** 하고, **하나라도 실패하면 롤백(Rollback)** 하는 것을 보장합니다.  
GORM에서는 트랜잭션을 사용하는 방법이 크게 두 가지 있으며, 내부적으로 Savepoint를 활용하여 중첩 트랜잭션과 유사한 효과(부분 롤백)를 낼 수 있습니다.

---

### 1.4.1 명시적인 Begin/Commit/Rollback

트랜잭션을 직접 시작(`Begin`), 커밋(`Commit`), 롤백(`Rollback`)하는 방식을 사용할 수 있습니다.  
이 방법은 트랜잭션의 시작과 종료 시점을 직접 제어할 수 있다는 장점이 있지만, 중간에 에러가 발생하거나 함수가 조기에 종료될 때 반드시 롤백을 호출해줘야 한다는 주의사항이 있습니다.

```go
tx := db.Begin() // 트랜잭션 시작

// 트랜잭션 내에서의 작업 (Create, Update, Delete 등)
if err := tx.Create(&user).Error; err != nil {
    // 작업 중 오류가 발생하면 즉시 롤백
    tx.Rollback()
    return
}

// 다른 작업들도 이어서 수행 가능
if err := tx.Model(&user).Update("Name", "NewName").Error; err != nil {
    tx.Rollback()
    return
}

// 모든 작업이 문제없이 끝났다면 커밋
if err := tx.Commit().Error; err != nil {
    // 커밋 과정에서 문제가 생기면 롤백 처리
    tx.Rollback()
    return
}
```

- **장점**: 트랜잭션의 시작과 종료 시점을 직접 관리할 수 있어 세밀하게 제어할 수 있습니다.
- **주의**:  
  - Begin부터 Commit/Rollback 사이에서는 반드시 동일한 `tx *gorm.DB` 객체를 사용해야 합니다.  
  - 함수 종료나 에러 발생 시 반드시 적절히 롤백 처리를 해야 합니다.

---

### 1.4.2 `db.Transaction` 헬퍼 함수 사용

GORM은 트랜잭션 처리를 간소화하기 위해 `Transaction` 헬퍼 함수를 제공합니다.  
이 함수는 내부적으로 Savepoint를 생성하여 다음과 같은 흐름으로 동작합니다.

1. 트랜잭션 시작(`Begin`) 및 Savepoint 생성  
2. 함수 본문 실행  
   - 에러 반환 시 해당 Savepoint까지 롤백(내부 블록만 취소)  
   - 에러 없이 종료되면 Savepoint가 해제되고 외부 트랜잭션에 변경사항이 반영됨(즉, 커밋)
   
**Savepoint란?**  
Savepoint는 이미 시작된 트랜잭션 내에서 임시 저장 지점을 설정하는 기능입니다.  
이를 활용하면 트랜잭션 내부의 특정 블록만 롤백할 수 있으므로, 전체 트랜잭션을 유지하면서 일부 작업만 취소할 수 있습니다.

```go
err := db.Transaction(func(tx *gorm.DB) error {
    // 여러 CRUD 작업 수행
    if err := tx.Create(&user).Error; err != nil {
        // 에러 발생 시 해당 Savepoint까지 롤백됨
        return err
    }

    // 중첩 트랜잭션(내부 Savepoint) 사용 예시:
    if err := tx.Transaction(func(nestedTx *gorm.DB) error {
        if err := nestedTx.Model(&user).Update("Age", 30).Error; err != nil {
            // 이 블록 내의 작업만 롤백됨
            return err
        }
        return nil // Savepoint 해제 후 변경사항은 외부 트랜잭션에 반영됨
    }); err != nil {
        return err
    }

    // 모든 작업이 성공하면 Savepoint가 해제되고 자동으로 커밋됨
    return nil
})

if err != nil {
    // 함수 내 에러 발생 시 자동으로 전체 트랜잭션 롤백됨
    fmt.Println("트랜잭션 오류:", err)
} else {
    fmt.Println("트랜잭션 성공, 모든 작업이 커밋되었습니다.")
}
```

- **장점**:  
  - 에러 관리가 간단해지고 코드가 깔끔해집니다.  
  - 내부 Savepoint 덕분에 중첩 트랜잭션과 유사한 효과(부분 롤백)를 낼 수 있습니다.
- **주의**:  
  - 함수 내에서 에러를 반환하면 해당 Savepoint 이후의 작업만 롤백됩니다.  
  - 모든 작업이 정상적으로 끝나야 `return nil`로 자동 커밋됩니다.

---

### 1.4.3 트랜잭션 주의 사항

- **트랜잭션 범위**:  
  - Begin부터 Commit/Rollback 사이에서만 유효하므로, 반드시 동일한 `tx *gorm.DB` 객체를 사용하여 CRUD 작업을 호출해야 합니다.
  
- **중첩 트랜잭션과 Savepoint**:  
  - GORM은 기본적으로 별도의 중첩 트랜잭션을 생성하지 않지만, Savepoint를 사용해 내부 블록만 롤백하는 기능을 제공합니다.
  - Savepoint를 활용할 때는, 내부 에러를 상위로 전파할 경우 전체 트랜잭션(outer 포함)을 롤백할 수 있도록 설계해야 합니다.
  - 여러 함수에서 트랜잭션을 사용할 때는 상위에서 시작한 `tx` 객체를 하위 함수에 인자로 전달하여 동일한 트랜잭션 컨텍스트를 유지하는 **전파(Propagation)** 방식을 권장합니다.

- **데드락(Deadlock) 주의**:  
  - 대규모 DB 작업을 트랜잭션으로 묶으면 락이 오래 유지되어 다른 트랜잭션과 충돌할 수 있으므로, 최소한의 작업만 포함시키도록 설계해야 합니다.

---

### 1.4.4 대량 작업(Bulk Operation)

대량 삽입(배치 Insert) 및 대량 업데이트도 트랜잭션 내에서 안정적으로 처리할 수 있습니다.  
아래 예제에서는 배치 Insert를 사용하여 여러 `User` 레코드를 한 번에 생성하는 방법을 보여줍니다.

```go
users := []User{
    {Name: "User1", Age: 20},
    {Name: "User2", Age: 25},
    {Name: "User3", Age: 30},
}

// 예시 1: db.Transaction 헬퍼 함수를 사용한 방식
err := db.Transaction(func(tx *gorm.DB) error {
    if err := tx.Create(&users).Error; err != nil {
        return err // 에러 발생 시 자동 롤백
    }
    // 추가 작업이 있다면 계속 처리 가능
    return nil // 정상 처리 시 자동 커밋
})

// 예시 2: 명시적 Begin/Commit/Rollback 방식
tx := db.Begin()
if err := tx.Create(&users).Error; err != nil {
    tx.Rollback()
    return
}
// 추가 작업...
if err := tx.Commit().Error; err != nil {
    tx.Rollback()
    return
}
```

- 슬라이스를 전달하면 DB에 따라 *Batch Insert*가 지원되므로, 대량 Insert 작업을 효율적으로 수행할 수 있습니다.
- 대량 업데이트의 경우 내부적으로 여러 쿼리가 실행될 수 있으므로 주의해야 합니다.

---

#### 요약

- **트랜잭션(Transaction)**: 여러 데이터베이스 작업을 하나의 논리적 단위로 묶어 원자성, 일관성, 격리성, 지속성을 보장합니다.
- **명시적인 Begin/Commit/Rollback** 방식과 **`db.Transaction` 헬퍼 함수** 방식 모두 사용 가능합니다.
- **Savepoint**를 활용하면 트랜잭션 내 특정 블록만 롤백할 수 있어, 중첩 트랜잭션과 유사한 부분 롤백 효과를 얻을 수 있습니다.
- 트랜잭션 범위 내에서는 반드시 동일한 `tx *gorm.DB` 객체를 사용하며, 여러 함수 간에 전파(Propagation)를 통해 동일 트랜잭션 컨텍스트를 유지해야 합니다.
- 대량 작업(Bulk Operation)도 트랜잭션을 적용하여 안정적으로 처리할 수 있습니다.

---

위 내용은 GORM에서 트랜잭션을 사용하는 다양한 방법과 Savepoint를 통한 부분 롤백 기능을 설명하며, 개발자가 보다 안전하고 효율적인 데이터베이스 작업을 구현할 수 있도록 돕습니다.