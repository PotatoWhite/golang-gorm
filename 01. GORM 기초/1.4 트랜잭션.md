## 1.4 Transaction

트랜잭션은 여러 CRUD 연산을 하나의 논리적 단위로 묶어 **모두 성공하면 커밋(Commit)** 하고, **하나라도 실패하면 롤백(Rollback)** 하는 것을 보장합니다. GORM에서 트랜잭션을 사용하는 방법은 크게 두 가지입니다.

### 1.4.1 명시적인 Begin/Commit/Rollback

트랜잭션을 직접 시작(`Begin`), 커밋(`Commit`), 롤백(`Rollback`)하는 방식을 사용할 수 있습니다.

```go
tx := db.Begin() // 트랜잭션 시작

// 트랜잭션 내에서의 작업 (Create, Update, Delete 등)
if err := tx.Create(&user).Error; err != nil {
    // 작업 중 오류가 발생하면 즉시 롤백
    tx.Rollback()
    return
}

// 다른 작업들도 이어서 수행 가능
if err := tx.Model(&user).Update("Name", "NewName").Error; err != nil {
    tx.Rollback()
    return
}

// 모든 작업이 문제없이 끝났다면 커밋
if err := tx.Commit().Error; err != nil {
    // 커밋 과정에서 문제가 생기면 다시 롤백 고려
    tx.Rollback()
    return
}
```

- **장점**: 트랜잭션의 시작/종료 시점을 직접 관리할 수 있어 세부적으로 제어하기가 편리합니다.  
- **주의**: Begin과 Commit, Rollback 시점을 직접 관리해야 하므로, 중간에 에러가 발생하거나 함수를 빠져나갈 때 반드시 롤백 처리가 필요합니다.

### 1.4.2 `db.Transaction` 헬퍼 함수 사용

GORM은 트랜잭션 처리를 간소화하기 위해 `Transaction` 헬퍼 함수를 제공합니다.  
이 함수는 내부적으로 아래와 같은 흐름을 포함합니다.

- 트랜잭션 시작(`Begin`)
- 함수 본문 실행
  - 에러 반환 시 자동으로 롤백
  - 에러가 없으면 자동으로 커밋

```go
err := db.Transaction(func(tx *gorm.DB) error {
    // 여러 CRUD 작업이 여기서 이루어짐
    if err := tx.Create(&user).Error; err != nil {
        // 오류 발생 시 에러 반환 -> 자동으로 Rollback
        return err
    }

    if err := tx.Model(&user).Update("Age", 30).Error; err != nil {
        return err
    }

    // 문제 없이 처리되면 nil 반환 -> 자동으로 Commit
    return nil
})

if err != nil {
    // 함수에서 에러가 반환된 경우
    fmt.Println("트랜잭션 오류:", err)
} else {
    fmt.Println("트랜잭션 성공, 모든 작업이 커밋되었습니다.")
}
```

- **장점**: 에러 관리가 간단하고, 코드가 깔끔해집니다.  
- **주의**: 함수 내에서 에러를 반환하면 즉시 롤백됩니다.  
  `return nil`이 트랜잭션 성공을 의미하므로, 모든 작업이 정상적으로 끝나면 `nil`을 반환해야 합니다.

### 1.4.3 트랜잭션 주의 사항

- **트랜잭션 범위**: Begin~Commit/Rollback 사이에서만 유효하므로, 같은 `tx *gorm.DB` 객체를 전달해야 합니다.  
  예) `tx.Create()`, `tx.Update()` 같이 **`tx`** 객체를 통해 호출.
- **중첩 트랜잭션**: GORM에서 중첩 트랜잭션은 추천되지 않습니다.  
  만약 여러 함수에서 트랜잭션을 사용할 일이 있다면, 상위에서 시작한 트랜잭션 객체를 하위 함수에 인자로 전달하는 방식을 권장합니다.
- **데드락(Deadlock) 주의**: 대규모 DB 작업을 트랜잭션으로 묶을 때, 락이 길게 유지되어 다른 트랜잭션들과 충돌이 생길 수 있습니다. 가급적 트랜잭션 안에서 최소한의 연산만 수행하도록 설계합니다.

### 1.4.4 대량 작업(Bulk Operation)

대량 삽입(배치 Insert) 및 대량 업데이트도 트랜잭션 안에서 함께 처리할 수 있습니다.  
아래 예제에서는 배치 Insert를 사용하여 한 번에 여러 `User` 레코드를 생성합니다.

```go
users := []User{
    {Name: "User1", Age: 20},
    {Name: "User2", Age: 25},
    {Name: "User3", Age: 30},
}

// 예시 1: 트랜잭션 헬퍼 함수를 사용하는 방법
err := db.Transaction(func(tx *gorm.DB) error {
    if err := tx.Create(&users).Error; err != nil {
        return err // 에러 반환 시 자동 롤백
    }
    // 다른 작업들이 있다면 계속 처리 가능
    return nil // 정상 처리 시 커밋
})

// 예시 2: 수동 트랜잭션 처리 방식
tx := db.Begin()
if err := tx.Create(&users).Error; err != nil {
    tx.Rollback()
    return
}
// 다른 작업들...
tx.Commit()
```

- `db.Create(&[]Model{})`와 같이 슬라이스를 직접 전달하면 DB에 따라 *Batch Insert*가 지원됩니다. (예: MySQL, PostgreSQL, SQLite 등)
- 대량 업데이트 시에도 `Updates`, `Save` 등과 함께 슬라이스를 전달할 수 있지만, 내부 동작은 Insert와 달리 실제로는 여러 쿼리가 실행될 수 있으므로 주의가 필요합니다.

---

#### 요약

- **트랜잭션(Transaction)**: 여러 데이터베이스 작업을 하나의 논리적 단위로 묶어 일관성을 보장.
- **명시적인 Begin/Commit/Rollback**과 **`db.Transaction` 헬퍼 함수** 모두 사용 가능.
- **트랜잭션 범위** 내에서는 동일한 `tx *gorm.DB` 객체를 사용하여 CRUD 작업을 처리.
- **대량 작업(Bulk Operation)**에도 트랜잭션을 적용하여, 한 번에 여러 레코드 작업을 안정적으로 처리할 수 있음.

이상으로 GORM에서의 트랜잭션과 대량 작업에 대해 살펴보았습니다. 여러 CRUD 연산을 안정적으로 묶어서 처리하며, 중간에 에러가 발생했을 경우 전체 작업을 되돌리는 방식으로 데이터 무결성과 일관성을 유지할 수 있습니다.